%!TEX root = ../thesis.tex

% *****************************************************************************
% ********************************** CHAPTER 4 ********************************
% *****************************************************************************

\chapter{Design and Architecture of EmbPub}

In the context of distributed systems, middleware for pub/sub communication
plays a fundamental role, as discussed in the previous chapter. This thesis
starts with the idea that embedded systems, particularly those with
heterogeneous processors, can be perceived as a form of distributed system.

While substantial progress has been made in the domain of pub/sub platforms for
traditional distributed systems, the adaptation of such platforms to satisfy
the needs of embedded systems is relatively unexplored territory.
This presents an opportune starting point leveraging existing knowledge while
navigating the unique challenges inherent in embedded systems.

As seen in the initial chapters, embedded systems have different requisites
from traditional systems.
Solutions in this domain must take into consideration low latency requirements,
safety considerations, and other specific needs for the specific application.

The primary goal of this project is to realize a pub/sub platform that exploits
the advantages offered by pub/sub communication while satisfying the needs of
embedded systems.

In this chapter are illustrated in detail the design of the pub/sub
platform created illustrating the architectural choices.

\section{Architecture}

The proposed pub/sub middleware starts with a layer architecture, carefully
structured to address the unique challenges posed by embedded systems. This
section illustrates the key components residing in each layer, providing
information about their roles, interactions, and contributions to the overall
efficacy of the communication framework.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/architecture_layers.png}
    \caption{Layered architecture of the solution}
\end{figure}

At the top of the architecture resides the Application layer, the interface
through which end-users and system components interact with the pub/sub
middleware. The Application layer provides a user-friendly interface for
configuring, consuming and producing messages within the ecosystem.
This layer is further subdivided into essential elements:

\begin{itemize}
    \item   Configurer: Responsible for configuring and maintain the
            information about the other components of the system.
    \item   Consumer: Facilitates the consumption of messages and the
            interactions needed for retrieving messages.
    \item   Broker: Serves as intermediary between producers and consumers,
            efficiently routing messages based on established topic
            subscription.
    \item   Producer: initiates the generation of messages into the
            communication network.
\end{itemize}

Under the Application layer, the Topic Manager layer serves as the manager of
all topic-related operations. The layer manages the creation, deletion and
tracks topics within the system. The seamless coordination of topics is one
of the most important element, making the Topic Manager one of the most
important element to provide flexible and dynamic communication infrastructure.

Coming down from the most abstract layers, the Quality of Service (QoS) layer
introduces elements designed to enhance the middleware's reliability and
safety. Within this layer, mechanisms for topic replication and the possibility
to define custom logic for the distribution of messages between a group of
consumers can be found.

Situated at the bottom of the stack there are the communication and disk
components, which is defined as the Operating System (OS) layer.
The Disk layer introduces a component for persistent data storage; classes
dedicated to saving records on disk have great importance to ensure data
durability.
This layer is particularly important when records have to be preserved beyond
runtime.

The other component at the base of the architecture is the Communication layer.
It plays a fundamental role for facilitating interaction among distributed
components within embedded systems.
Leveraging the APIs provided by Texas Instruments, this layer ensures robust
and efficient communication between different processors.

\section{Class interactions}

The image (figure \ref{fig:class_diagram}) details the different components
that enable the exchange of messages between producers and consumers in a
distributed environment.

The architecture is composed of various entities, including a cluster,
consumer groups, brokers, replicas, partitions, records, producers and
consumers. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/class_diagram.png}
    \caption{Interaction between classes}
    \label{fig:class_diagram}
\end{figure}

The most interesting components are the following ones:

\begin{itemize}
    \item   Cluster: the cluster is the foundation of the middleware, acting as
            a collection of brokers that facilitate message exchange and
            compose the general system.
    \item   Consumer groups: Consumer groups organize consumers into logical
            units, allowing them to divide and conquer the workload of
            consuming messages from a topic. The approach enhances parallelism
            and scalability.
    \item   Replicas: replicas are copies of partitions stored on different
            brokers, providing redundancy and fault tolerance. If the primary
            broker of a partition fails, a replica can take over its role,
            ensuring uninterrupted message delivery.
\end{itemize}

These ideas are taken from Apache kafka and applied to the embedded system
domain.

\section{Class Diagrams}

In the current section the class diagrams for the different layers will be
analyzed.

\subsection{Topic Manager}

The Topic Manager layer is responsible for managing the topic metadata and
handling interactions between producers, consumers and brokers. It is a crucial
component of the middleware, ensuring efficient message exchange and ensuring
the integrity of the messaging system.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/class_diagram_topic_manager.png}
    \caption{Class diagram of the topic manager layer}
    \label{fig:class_diagram_topic_manager}
\end{figure}

The topic manager layer interacts with the broker component to maintain the
state of topics, including the creation, deletion and modification.
It also manages subscriptions, ensuring that consumers are notified of messages
published to topics they are subscribed to. Additionally, the topic manager
layer handles message routing, directing messages to the appropriate partitions
within each topic.

The topic manager layer is implemented as a collection of components that work
together to provide the necessary functionality. These components include:

\begin{enumerate}
    \item   TopicFactory: this component is responsible for creating new
            topics and managing their metadata. It ensures that topics are
            created with the appropriate configurations and that they are
            registered with the broker.
    \item   TopicHandler: This component handles interactions between producers
            and consumers. It receives messages from producers, adds them to
            the appropriate partitions, and updates topic metadata. It also
            receives subscription requests from consumers and manages
            subscriptions accordingly.
    \item   SystemManager: this component is of fundamental importance for all
            the system operations. It provides a centralized interface for
            managing the communication with the configurer. It also provides
            all the information about the current status of the cluster.
\end{enumerate}

\subsection{QoS}

The QoS layer is responsible for managing the quality of services (QoS) of the
system.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{Figures/class_diagram_QoS.png}
    \caption{Class diagram of the QoS layer}
\end{figure}

The components are:

\begin{itemize}
    \item   ReplicaHandler: this component is used for replicating topics to
            ensure high availability and durability of data. It takes a
            TopicMetadata object as a parameter, which contains information
            about the topic to be replicated. The ReplicaHandler then
            replicates the topic to a specified number of brokers.
    \item   DistributionLogic: this component is responsible for distributing
            messages to consumer groups in a way that meets the QoS
            requirements of the application. It takes a ConsumerGroup object
            as a paramter, which contains information about the consumers
            belonging to the group that has to be serviced.
            The DistributionLogic then distributes the messages to the consumer
            group in a way that ensures that all messages are eventually
            delivered to at least one consumer.
\end{itemize}

The QoS layer has the necessity to interact with other elements of the system
in order to work. In particular, the complexity of the above layer, the topic
manager, gives the possibility to simplify this layer, which will exploits
the classes given by the communication layer to perform the exchange of
messages in a simple way.

\subsection{Communication}

The communication layer is responsible for sending and receiving messages
between the processors in the system and outside of the embedded system.
The layer is one of the most important ones in the domain of a
platform for pub/sub communication. This layer takes into consideration the
necessity for embedded system of using restrained resources.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/class_diagram_communication.png}
    \caption{Class diagram of the communication layer}
    \label{fig:class_diagram_communication}
\end{figure}

The components seen in the class diagram
(figure \ref{fig:class_diagram_communication}) are:

\begin{itemize}
    \item   CommunicationFactory: this class is responsible for creating
            instances of IPCCommunication or TCPCommunication objects. It takes
            a CommunicationType parameter.
    \item   CommunicationType: this enumeration defines the two types of
            communication that can be created: IPC or TCP.
    \item   IPCCommunication: This class is used for communication between
            processors on the same device. It provides methods for sending and
            receiving messages.
    \item   TCPCommunication: this class is used for communication between
            processors on different devices. it provides methods for sending
            and receiving messages over a TCP socket.
\end{itemize}

\subsection{Domain level}

The image below (figures \ref{fig:class_diagram_domain_1} and \ref{fig:class_diagram_domain_2})
shows all the classes that compose the domain of the system.
The domain classes can be used by all the layer of the application (primarily
from the top level layers) and they contain information of the specific class
and the interaction with the other elements.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/class_diagram_domain_1.png}
    \caption{Class diagram of domain of the middleware 1}
    \label{fig:class_diagram_domain_1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/class_diagram_domain_2.png}
    \caption{Class diagram of domain of the middleware 2}
    \label{fig:class_diagram_domain_2}
\end{figure}

\section{Sequence Diagram}

The following section will use sequence diagrams to visualize the steps needed 
and the classes interaction to perform the most important operations of the
system.

\subsection{Consumer asking for a record}

The sequence diagram depicts the interaction between a message consumer and
the rest of the system. The consumer initiates the interaction by requesting
a TopicProxy from the TopicFactory.
The pattern proxy helps to hide all the operations that will be done underneath
to perform the communication between the different processors, making it seem
like a local communication.
The consumer then establishes a communication channel with the broker
containing the interested topic using the CommunicationFactory.
The SystemManager is used to retrieve the information about the cluster status.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/sequence_diagram_consumer_poll.png}
    \caption{Sequence diagram of a consumer asking for a record}
\end{figure}

\subsection{Publisher sending a record}

The publishing of a message is handled in a similar way to the consumer read.
All the details is hidden under the TopicProxy and the SystemManager.

\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/sequence_diagram_producer.png}
    \caption{Sequence diagram of a producer publishing a record}
\end{figure}

\subsection{Synchronization of the cluster status}

The synchronization of the cluster status is a fundamental operation in a
distributed system.
The operation is divided in two steps:

\begin{enumerate}
    \item   The first one is performed by the system manager to ask to the
            centralized "server" (configurer) about the information. 
    \item   The second one is performed by the configurer which responds to
            the request sent by the system manager.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{Figures/sequence_diagram_cluster_status_configurer.png}
    \caption{Sequence diagram of the configurer operations done for the cluster
             status synchronization}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{Figures/sequence_diagram_cluster_status_system_manager.png}
    \caption{Sequence diagram of the system manager operations done for the
             cluster status synchronization}
\end{figure}

\subsection{Broker receiving a record}

One of the most important operation is the possibility to store the records,
sent by the producers, in a broker. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/sequence_diagram_broker.png}
    \caption{Sequence diagram of a broker receiving a record to store}
\end{figure}

\subsection{Consumer subscribing to a topic}

The subscription process involves a consumer expressing its interest in a
specific topic, initiating a series of interaction with the underlying system.
The Consumer class uses the usual TopicProxy to communicate with the broker
holding the needed topic.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/sequence_diagram_subscription.png}
    \caption{Sequence diagram of a consumer subscribing to a topic handled by
             a broker}
\end{figure}

